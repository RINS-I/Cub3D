
// void	put_a_ray(t_map *map, int x, int y, int color)
// {
// 	double	angle;
// 	int	i;

// 	angle = map->coor.angle - (30 * M_PI / 180);
// 	while (angle < (map->coor.angle + (30 * M_PI / 180)))
// 	{
// 		i = 0;
// 		while (!check_if_wall(map, x + roundf(cos(angle) * i),
// 			y + roundf(sin(angle) * i)))
// 		{
// 			my_mlx_put_pixel(&map->img,
// 				x + roundf(cos(angle) * i),
// 				y + roundf(sin(angle) * i), color);
// 			i++;
// 		}
// 		map->coor.d = i;
// 		draw_walls(map, color);
// 		map->wall.x++;
// 		angle += ((60.0 / 500) * (M_PI / 180));
// 	}
// 	map->wall.x = 0;
// 	map->wall.y = 0;
// }



void	inter_hori_wall(t_map *map, int x, int y, double angle)
{
	if (angle < 0)
		angle += 2 * M_PI;
	if (angle > (3 * M_PI / 2) && angle < 2 * M_PI)
		map->wall.gh_x = 64 / tan(2 * M_PI - angle);
	else if (angle > M_PI && angle < (3 * M_PI / 2))
		map->wall.gh_x = 64 / tan(M_PI - angle);
	else
		map->wall.gh_x = 64 / tan(angle);
	if (angle >= 0 && angle <= M_PI)
	{
		map->wall.gh_y = 64;
		map->wall.h_y = (y / 64) * 64 + 64;
	}
	else if (angle > M_PI && angle <= 2 * M_PI)
	{
		map->wall.gh_y = -64;
		map->wall.h_y = (y / 64) * 64 - 1;
	}
	if (angle > (3 * M_PI / 2) && angle < 2 * M_PI)
		map->wall.h_x = x + (y - map->wall.h_y) / tan(2 * M_PI - angle);
	else if (angle > M_PI && angle < (3 * M_PI / 2))
		map->wall.h_x = x + (y - map->wall.h_y) / tan(M_PI - angle);
	else
		map->wall.h_x = x + (map->wall.h_y - y) / tan(angle);
	draw_cub_inter(map, map->wall.h_x, map->wall.h_y, angle);
}


void	inter_ver_wall(t_map *map, int x, int y, double angle)
{
	if (angle < 0)
		angle += 2 * M_PI;
	if (angle <= (M_PI / 2) || angle >= (3 * M_PI / 2))
		map->wall.gv_y = 64 * tan(angle);
	else
		map->wall.gv_y = 64 * tan(2 * M_PI - angle);
	if (angle <= (M_PI / 2) || angle >= (3 * M_PI / 2))
	{
		map->wall.gv_x = 64;
		map->wall.v_x = (x / 64) * 64 + 64;
	}
	else
	{
		map->wall.gv_x = -64;
		map->wall.v_x = (x / 64) * 64 - 1;
	}
	if (angle <= (M_PI / 2) || angle >= (3 * M_PI / 2))
		map->wall.v_y = y + (map->wall.v_x - x) * tan(angle);
	else
		map->wall.v_y = y + (x - map->wall.v_x) * tan(2 * M_PI - angle);
	draw_cub_ver(map, map->wall.v_x, map->wall.v_y, angle);
}

///////inter/////////////

	// if (x < map->coor.x * 64 && y < map->coor.y * 64
	// 	&& x > 0 && y > 0)
	// 	my_mlx_put_pixel(&map->img, roundf(x) ,
	// 		roundf(y) , 0xFF0000);
		// fill_cub_player(map, x, y, 0x0000);


void	coor_of_ver_wall(t_map *map,double x,double y)
{
	map->coor.d_v = sqrt(pow(map->coor.x * 64, 2) + pow(map->coor.y * 64, 2));
	while ((int)x < map->coor.x * 64 && (int)y < map->coor.y * 64
		&& (int)x >= 0 && (int)y >= 0
		&& !check_if_wall(map, x, y))
	{
		//fill_cub_player(map, x, y, 0xff0000);
		x += map->wall.gv_x;
		y += map->wall.gv_y;
	}
	if ((int)x < map->coor.x * 64 && (int)y < map->coor.y * 64
		&& (int)x >= 0 && (int)y >= 0
		&& check_if_wall(map, x, y))
		map->coor.d_v = distance_wall(map, x, y);
	// if (x < map->coor.x * 64 && y < map->coor.y * 64
	// 	&& x > 0 && y > 0)
	// 	my_mlx_put_pixel(&map->img, roundf(x) ,
	// 		roundf(y) , 0xFF0000);
		// fill_cub_player(map, x, y, 0x0000);
}
